// Foospin Ball
// David Gardiner
// For MechE 1720

#include "U8glib.h" // For Nokia 5110 LCD Display
#include <Servo.h>  // For Servo

/* ----- PINS ----- */
// Touch Sensors (any GPIO - not PWM) (5V)
#define sensor1 PL_0 // Mouth (lose) DIGITAL
#define sensor2 PL_1 // Top (win) DIGITAL#define sensor3 PK_5 // Castle left
#define sensor4 PM_0 // Castle middle
#define sensor5 PM_1 // Castle right
#define sensor6 PM_2 // Behind tail 
#define sensor7 PH_0 // After tail raise left 
#define sensor8 PH_1 // After tail raise right 
#define sensor9 PK_6 // Tail left
#define sensor10 PK_7 // Tail Middle

// Nokia 5110 (3.3V)
U8GLIB_PCD8544 u8g(PQ_0, PQ_2, PE_3, PE_1, PE_2);    // SPI Com: SCK = PQ_0, MOSI = PQ_2, SCE = PE_3, D/C = PE_1, Reset = PE_2
#define LCD_LED PF_1

// Start Button 
#define startPin PL_4 

// Speaker 
#define speakerOut PG_1

// Head LEDs
#define left_eye PL_2
#define right_eye PL_3

// Servos
#define s_left PF_2
#define s_right PF_3
#define s_tail PG_0

Servo left_door;
Servo right_door;
Servo tail;
bool tailUp = false;
int tailTime = 40;
bool buttonStart;
int count = 90;
int score = 0;
int curr = 0;
int prev = 0;
int curr_hit = 0;
int prev_hit = 0;
int interval = 1000;
int DEBUG = 1;
int num_notes = 43;
int high_score = 0;
int buttonState = 0;
bool start = false;
bool win = false;
bool lose = false;
int loopa = 0;
bool gameover = false;
int i = 40;

// Output score and timer
void output() { 
  u8g.setFont(u8g_font_helvR08);
  char t_buf[10];
  snprintf (t_buf, 10, "%d", count);
  u8g.drawStr(3, 10, "Timer: ");
  u8g.drawStr(32, 10, t_buf);  
  char s_buf[10];
  snprintf (s_buf, 10, "%d", score);
  u8g.drawStr(3, 20, "Score: ");
  u8g.drawStr(35, 20, s_buf);  
  u8g.setFont(u8g_font_helvB10);
  if(tailUp)
    if(count % 2 == 0)
      u8g.drawStr(3, 35, "Tail Moving!");
}

void output_win() {
  u8g.setFont(u8g_font_helvB10);
  u8g.drawStr(10, 19, "You win!");
}

void output_lose() {
  u8g.setFont(u8g_font_helvB10);
  u8g.drawStr(7, 19, "You lose!");
}

// Bitmap Bilbo
#define b_width 84
#define b_height 48
static unsigned char b_bits[] = {
  0x00, 0x0C, 0x00, 0xA8, 0xD7, 0xFD, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x0E, 0x00, 0x58, 0xA5, 0xF7, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
  0x00, 0xA8, 0x4B, 0xFA, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 
  0xB8, 0x92, 0xD6, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0xB0, 
  0x3D, 0xBD, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0xC8, 0x2A, 
  0xF7, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xB0, 0x20, 0xA9, 
  0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0xA0, 0x45, 0xAB, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x60, 0x80, 0x6A, 0x1F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xD0, 0x12, 0xD7, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x00, 0x20, 0x65, 0xEB, 0x06, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x06, 0x00, 0xC0, 0xA4, 0xD6, 0x07, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0E, 0x00, 0x80, 0x81, 0xB6, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x0A, 0x00, 0x40, 0x14, 0xEF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
  0x00, 0x80, 0xE3, 0xE5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 
  0x80, 0x0A, 0xDD, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 
  0x2B, 0xF9, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x80, 0x8A, 
  0xDE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x80, 0x55, 0x76, 
  0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xA0, 0xD5, 0xED, 0xFF, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xE0, 0x55, 0x6F, 0x7F, 0x3F, 
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x98, 0xA3, 0xFA, 0xDF, 0xFF, 0x00, 
  0x00, 0x00, 0x00, 0x06, 0x00, 0xF6, 0x5A, 0xAB, 0xFF, 0xFF, 0x03, 0x00, 
  0x00, 0x00, 0x06, 0x80, 0xAE, 0xC7, 0xBA, 0x7F, 0xFF, 0x03, 0x00, 0x00, 
  0x00, 0x06, 0xC0, 0xFD, 0x9D, 0xF5, 0xFF, 0xDF, 0x07, 0x00, 0x00, 0x00, 
  0x06, 0x60, 0xB7, 0x73, 0xDD, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x0E, 
  0xF0, 0x6E, 0xA7, 0xBB, 0x7A, 0xBF, 0x0F, 0x00, 0x00, 0x00, 0x06, 0xE0, 
  0xFF, 0x57, 0xCC, 0xF7, 0x7E, 0x0F, 0x00, 0x00, 0x00, 0x06, 0x70, 0xFF, 
  0xD7, 0xCB, 0xFF, 0xFB, 0x1F, 0x00, 0x00, 0x00, 0x06, 0xD0, 0x7B, 0x07, 
  0xE6, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x06, 0xF8, 0xDF, 0x8F, 0xE5, 
  0xEF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x06, 0xF8, 0xFF, 0x0F, 0xE6, 0xBF, 
  0xFF, 0x7F, 0x00, 0x00, 0x00, 0x06, 0x58, 0x7F, 0xDF, 0xF4, 0xFF, 0xFF, 
  0xFF, 0x00, 0x00, 0x00, 0x07, 0xFC, 0xDB, 0x8F, 0xB2, 0xFF, 0xFF, 0xFF, 
  0x00, 0x00, 0x00, 0x6F, 0xF8, 0xFF, 0x4F, 0xF5, 0x7F, 0xFF, 0xFF, 0x01, 
  0x00, 0x00, 0x3F, 0xF4, 0xF7, 0x9F, 0xF3, 0xFD, 0xFF, 0xFF, 0x01, 0x00, 
  0x00, 0x3F, 0xFC, 0xDF, 0x9F, 0xF6, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xC0, 
  0x0F, 0xFE, 0xFF, 0xAF, 0xF9, 0x7D, 0xFF, 0xFF, 0x03, 0x00, 0xE0, 0x07, 
  0xFF, 0xDF, 0x7F, 0xF3, 0xEF, 0xFF, 0xFF, 0x07, 0x00, 0x40, 0x0F, 0xF7, 
  0x7F, 0x5F, 0xFB, 0xFF, 0xFF, 0xBF, 0x07, 0x00, 0x80, 0x0E, 0xFF, 0xFF, 
  0xBF, 0xFA, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xEF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xA0, 0x34, 0xFF, 0xDF, 0xBF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x60, 0x3F, 0xFF, 0x7F, 0x7F, 0xFD, 0xFF, 
  0xFF, 0xFF, 0x0F, 0x00, 0x40, 0xEA, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x0F, 0x00, 0xD0, 0xDD, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 
  0x1F, 0x00, 0x20, 0xFB, 0xFF, 0xFF, 0xBF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 
  0x00, 0x20, 0xEB, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 
  };

// Bitmap Hobbit
#define h_width 84
#define h_height 48
static unsigned char h_bits[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 
  0x00, 0x00, 0x84, 0x02, 0x00, 0xA0, 0x08, 0x0A, 0x04, 0x68, 0x00, 0x8F, 
  0x28, 0x28, 0x0C, 0x00, 0x00, 0xC3, 0xF5, 0x07, 0x20, 0x00, 0x00, 0x40, 
  0x10, 0x28, 0x20, 0x00, 0x23, 0x10, 0x0C, 0x20, 0x00, 0x07, 0x00, 0x20, 
  0x30, 0xDA, 0x01, 0x22, 0x18, 0x00, 0x20, 0x00, 0x02, 0x00, 0x28, 0x20, 
  0x08, 0x06, 0x03, 0x10, 0x00, 0x20, 0x00, 0x04, 0x02, 0x20, 0x20, 0x08, 
  0x04, 0x02, 0x10, 0x00, 0x20, 0x00, 0xC2, 0x14, 0x10, 0x10, 0x08, 0x04, 
  0x00, 0x18, 0x00, 0x20, 0x00, 0x06, 0x20, 0x20, 0x08, 0x08, 0x04, 0x03, 
  0x18, 0x00, 0x60, 0xF5, 0x41, 0x80, 0x68, 0x0B, 0x08, 0x02, 0x00, 0x00, 
  0x00, 0x60, 0x00, 0x05, 0x00, 0x11, 0x10, 0x58, 0x00, 0x03, 0x10, 0x00, 
  0x00, 0x00, 0x22, 0x00, 0x31, 0xB0, 0x88, 0x0A, 0x02, 0x18, 0x00, 0x30, 
  0x00, 0x02, 0x00, 0x20, 0x00, 0x08, 0x10, 0x01, 0x10, 0x00, 0x20, 0x00, 
  0x54, 0x00, 0x13, 0x80, 0x08, 0x18, 0x03, 0x18, 0x00, 0x60, 0x00, 0x21, 
  0x00, 0x30, 0x80, 0x09, 0x10, 0x02, 0x10, 0x00, 0x00, 0x00, 0x42, 0x00, 
  0x21, 0x40, 0x0C, 0x10, 0x01, 0x10, 0x00, 0x20, 0x00, 0x24, 0x80, 0x08, 
  0x60, 0x08, 0x08, 0x03, 0x10, 0x00, 0x30, 0x00, 0x83, 0xC1, 0x70, 0x20, 
  0x18, 0x0C, 0x02, 0x10, 0x00, 0x20, 0x80, 0x06, 0x1A, 0xAC, 0x1F, 0xF4, 
  0xC3, 0x0F, 0x14, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x18, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
  0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
  0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x30, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x78, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x40, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x30, 0x06, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x00, 0x00, 0x00, 0x00, 0x60, 0xF8, 0xF8, 0x10, 0x3E, 0x3E, 0x08, 0x44, 
  0x18, 0xEC, 0x07, 0x70, 0x98, 0x04, 0x31, 0xC2, 0x06, 0x08, 0xC0, 0x30, 
  0x44, 0x00, 0xD0, 0x90, 0x05, 0x28, 0x86, 0x02, 0x0C, 0xA0, 0x28, 0x4C, 
  0x00, 0xC8, 0x90, 0x06, 0x28, 0x82, 0x24, 0x0C, 0x80, 0x61, 0x4A, 0x00, 
  0x88, 0x71, 0x04, 0x78, 0x86, 0x3D, 0x0C, 0xF2, 0x41, 0xEC, 0x07, 0xF8, 
  0x99, 0x04, 0x64, 0xC2, 0x06, 0x08, 0x17, 0x49, 0x49, 0x00, 0x04, 0x89, 
  0x0D, 0xC1, 0x44, 0x02, 0x0C, 0x02, 0x83, 0x48, 0x04, 0x04, 0x1A, 0xD1, 
  0xC6, 0x3F, 0x3E, 0x18, 0x1A, 0x8D, 0xF8, 0x07, 0x0C, 0x02, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
  0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Draw Hobbit
void drawh()
{
  u8g.drawXBMP( 0, 0, h_width, h_height, h_bits);
}

// Draw Bilbo
void drawb()
{
  u8g.drawXBMP( 0, 0, b_width, b_height, b_bits);
}

// TONES  ==========================================
// Start by defining the relationship between 
//       note, period, &  frequency. 
#define  c     7692    // 130
#define  db    7246    // 138
#define  d     6849    // 146
#define  eb    6451    // 155
#define  e     6097    // 164
#define  f     5747    // 174
#define  gb    5434    // 184
#define  g     5128    // 195
#define  ab    4830    // 207
#define  a     4545    // 220
#define  bb    4291    // 233
#define  b     4065    // 246
#define  C     3830    // 261 Hz
#define  Db    3610    // 277 
#define  D     3400    // 294 Hz
#define  Eb    3215    // 311 
#define  E     3038    // 329 Hz 
#define  F     2864    // 349 Hz 
#define  Gb    2710    // 369
#define  G     2550    // 392 Hz 
#define  Ab    2409    // 415
#define  A     2272    // 440 Hz
#define  Bb    2145    // 466 
#define  B     2028    // 493 Hz 
#define  R     0       // Rest

// Misty Mountain Cold
int melody[] = { d,  f,  g,   bb, C,  D,  C,  bb, a,  g,   d,
                 f,  g,  a,   bb, C,  bb, a,  g,   R,  d,  f,  g,
                 g,  g,   bb, C,  bb,  a,  f,  g,   d,  f,  g,  a,  a,  bb,  C,  bb, a,  g,
                 a, R};
int beats[]  = { 64, 64, 192, 64, 64, 32, 32, 64, 64, 192, 64,
                 64, 64, 192, 64, 64, 32, 32, 256, 64, 64, 64, 64,
                 64, 128, 64, 32, 32,  64, 64, 192, 64, 64, 64, 64, 128, 64, 32, 32, 64, 64,
                 256, 128}; 

// Set overall tempo
long tempo = 10000;
// Set length of pause between notes
int pause = 1000;

// Initialize core variables
int tone_ = 0;
int beat = 0;
long duration  = 0;

// PLAY TONE  ==============================================
// Pulse the speaker to play a tone for a particular duration
void playTone() {
  long elapsed_time = 0;
  if (tone_ > 0) { // if this isn't a Rest beat, while the tone has 
    //  played less long than 'duration', pulse speaker HIGH and LOW
    while (elapsed_time < duration) {

      digitalWrite(speakerOut,HIGH);
      delayMicroseconds(tone_ / 2);

      // DOWN
      digitalWrite(speakerOut, LOW);
      delayMicroseconds(tone_ / 2);

      // Keep track of how long we pulsed
      elapsed_time += (tone_);
    } 
  }
  else { // Rest beat; loop times delay
      delayMicroseconds(duration);  
  }                                
}                                 

void setup(void) {

  Serial.begin(9600);
  left_door.attach(s_left); // PWM pin
  right_door.attach(s_right); // PWM pin
  tail.attach(s_tail); // PWM pin

  pinMode(LCD_LED, OUTPUT);
  pinMode(startPin, INPUT);
  analogWrite(LCD_LED, 255);
  pinMode(speakerOut, OUTPUT);
  pinMode(left_eye, OUTPUT);
  pinMode(right_eye, OUTPUT);
  pinMode(sensor1, INPUT);
  pinMode(sensor2, INPUT);
  pinMode(sensor3, INPUT);
  pinMode(sensor4, INPUT);
  pinMode(sensor5, INPUT);
  pinMode(sensor6, INPUT);
  pinMode(sensor7, INPUT);
  pinMode(sensor8, INPUT);
  pinMode(sensor9, INPUT);
  pinMode(sensor10, INPUT);
  

  // Turn on head LEDs
  digitalWrite(left_eye, HIGH);
  digitalWrite(right_eye, HIGH);

  left_door.write(170);
  right_door.write(0);

  u8g.setRot180(); // Rotate 180
  u8g.setFont(u8g_font_helvB10);

  #if defined(ARDUINO)
    pinMode(PQ_0, OUTPUT);           
    digitalWrite(PQ_0, HIGH);  
  #endif
}

void loop(void) {
  u8g.firstPage();
  bool went_up = false;
  count = 90;
  int out_count = 0;
  loopa = 0;
  prev_hit = 0;
  curr_hit = 0;
  win = false;
  lose = false;
  tailUp = false;
  score = 0;
  int tail_pos = 90;
  i = 0;

  buttonState = digitalRead(startPin);
  Serial.print("Press start!");
  if(buttonState == HIGH)
    buttonStart = true;
  else
    buttonStart = false;

  // If button started HIGH
  if(buttonStart) {
    do {
      u8g.firstPage();
      buttonState = digitalRead(startPin);
      Serial.print(buttonState);
      if(i==43)
        i = 0;
      if(out_count % 15 < 5)
      {
        do // draw Bilbo
        {
          drawh();
        } while(u8g.nextPage());
      }
      else if(out_count % 15 < 10)
      {
        do // draw Bilbo
        {
          drawb();
        } while(u8g.nextPage());
      }
      else
      {
        do {
          u8g.drawStr(0, 24, "Press Start!");
        } while(u8g.nextPage());
      }
      tone_ = melody[i];
      beat = beats[i];
  
      duration = beat * tempo; // Set up timing
  
      playTone(); 
      // A pause between notes...
      delayMicroseconds(pause);

      out_count++;
      i++;
    } while(buttonState == HIGH);
  }

  // If button started LOW
  else {
    do {
      u8g.firstPage();
      buttonState = digitalRead(startPin);
      Serial.print(buttonState);
      if(i==43)
        i = 0;
      if(out_count % 15 < 5)
      {
        do // draw Bilbo
        {
          drawh();
        } while(u8g.nextPage());
      }
      else if(out_count % 15 < 10)
      {
        do // draw Bilbo
        {
          drawb();
        } while(u8g.nextPage());
      }
      else
      {
        do {
          u8g.drawStr(0, 24, "Press Start!");
        } while(u8g.nextPage());
      }
      tone_ = melody[i];
      beat = beats[i];
  
      duration = beat * tempo; // Set up timing
  
      playTone(); 
      // A pause between notes...
      delayMicroseconds(pause);

      out_count++;
      i++;
    } while(buttonState == LOW);
  }


  // Open the doors to start the game
  for(int pos = 0; pos < 90; pos++)
  {
    right_door.write(pos);
    left_door.write(170-pos);
    Serial.println("OPENING");
    //delay(15);
  }

  // Close the doors
  for(int pos = 90; pos >=1; pos--)
  {
    right_door.write(pos);
    left_door.write(170-pos);
    Serial.println("CLOSING");
    //delay(15);
  }
  
  do // Game loop
  {
    u8g.firstPage();
    pinMode(sensor1, INPUT);
    pinMode(sensor2, INPUT);
    pinMode(sensor3, INPUT);
    pinMode(sensor4, INPUT);
    pinMode(sensor5, INPUT);
    pinMode(sensor6, INPUT);
    pinMode(sensor7, INPUT);
    pinMode(sensor8, INPUT);
    pinMode(sensor9, INPUT);
    pinMode(sensor10, INPUT);
    int s1 = digitalRead(sensor1);
    int s2 = digitalRead(sensor2);
    int s3 = digitalRead(sensor3);
    int s4 = digitalRead(sensor4);
    int s5 = digitalRead(sensor5);
    int s6 = digitalRead(sensor6);
    int s7 = digitalRead(sensor7);
    int s8 = digitalRead(sensor8);
    int s9 = digitalRead(sensor9);
    int s10 = digitalRead(sensor10);

    curr_hit = millis();
    // If sensors are touched
    if(s1 == HIGH || s2 == HIGH || s3 == HIGH || s4 == HIGH || s5 == HIGH || s6 == HIGH || s7 == HIGH || s8 == HIGH || s9 == HIGH || s10 == HIGH) {
      if(s1 == HIGH)
        lose = true;
      else if(s2 == HIGH)
        win = true;
      if(curr_hit-prev_hit > 1000) { 
        if(s3 == HIGH)
          score += 20;
        else if(s4 == HIGH)
          score += 10;
        else if(s5 == HIGH)
        {
          score += 20;
          Serial.print("TOUCHING");
        }
        else if(s6 == HIGH)
          score += 30;
        else if(s7 == HIGH)
          score += 40;
        else if(s8 == HIGH)
          score += 50;
        else if(s9 == HIGH)
          score += 30;
        else if(s10 == HIGH)
          score += 10;
        prev_hit = curr_hit;
      }
    }
      
    do {
      output();
    } while(u8g.nextPage());
    if(count <= tailTime && count > tailTime - 8) {
      Serial.print("TAIL");
      tailUp = true;
      went_up = true;
      tail_pos = 90 + (10 * (count - tailTime));
      tail.write(90 + (10 * (count - tailTime)));
      Serial.println(tail_pos);
    }

    if(count <= tailTime - 8);
      tailUp = false;
      
    curr = millis();
    if(curr - prev > interval)
    {
      /*Serial.print("Timer: ");
      Serial.print(count);
      Serial.println("");*/
      prev = curr;
      count--;
    }
  /*Serial.print("Score: ");
  Serial.print(score);
  Serial.println("");*/
  } while (!win && !lose && count > 0);

  if(count == 0)
    lose = true;
    
  u8g.firstPage();

  gameover = true;

  if(win) {
    do {
      output_win();
    } while(u8g.nextPage());
  }
  else
  {
    do {
      output_lose();
    } while(u8g.nextPage());
  }

  delay(5000);
  
    // Move tail down
  if(went_up) {
    for(tail_pos = 20; tail_pos <= 90; tail_pos++) {
      tail.write(tail_pos);
      delay(15);
    }
  }
}

